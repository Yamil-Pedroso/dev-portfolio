{
  "version": 3,
  "sources": ["../../react-use-gesture/src/utils/math.ts", "../../react-use-gesture/src/utils/rubberband.ts", "../../react-use-gesture/src/utils/utils.ts", "../../react-use-gesture/src/utils/resolveOptionsWith.ts", "../../react-use-gesture/src/utils/event.ts", "../../react-use-gesture/src/utils/config.ts", "../../react-use-gesture/src/hooks/buildConfig.ts", "../../react-use-gesture/src/utils/state.ts", "../../react-use-gesture/src/recognizers/Recognizer.ts", "../../react-use-gesture/src/Controller.ts", "../../react-use-gesture/src/hooks/useRecognizers.ts", "../../react-use-gesture/src/recognizers/CoordinatesRecognizer.ts", "../../react-use-gesture/src/recognizers/DragRecognizer.ts", "../../react-use-gesture/src/utils/memoize-one.ts", "../../react-use-gesture/src/utils/react-fast-compare.ts", "../../react-use-gesture/src/hooks/useDrag.ts", "../../react-use-gesture/src/recognizers/DistanceAngleRecognizer.ts", "../../react-use-gesture/src/recognizers/PinchRecognizer.ts", "../../react-use-gesture/src/hooks/usePinch.ts", "../../react-use-gesture/src/recognizers/WheelRecognizer.ts", "../../react-use-gesture/src/hooks/useWheel.ts", "../../react-use-gesture/src/recognizers/MoveRecognizer.ts", "../../react-use-gesture/src/hooks/useMove.ts", "../../react-use-gesture/src/hooks/useHover.ts", "../../react-use-gesture/src/recognizers/ScrollRecognizer.ts", "../../react-use-gesture/src/hooks/useScroll.ts", "../../react-use-gesture/src/hooks/useGesture.ts"],
  "sourcesContent": ["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\ninterface Kinematics {\n  velocities: number[]\n  velocity: number\n  distance: number\n  direction: number[]\n}\n\nexport function calculateAllGeometry<T extends number[]>(movement: T, delta: T = movement) {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n\n  const direction = delta.map(v => alpha * v) as T\n  const distance = calculateDistance(movement)\n\n  return { distance, direction }\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, dt: number): Kinematics {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n  const beta = dt === 0 ? 0 : 1 / dt\n\n  const velocity = beta * dl\n  const velocities = delta.map(v => beta * v)\n  const direction = delta.map(v => alpha * v)\n  const distance = calculateDistance(movement)\n\n  return { velocities, velocity, distance, direction }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n", "function minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n  if (position < min) return -rubberband(min - position, max - min, constant) + min\n  if (position > max) return +rubberband(position - max, max - min, constant) + max\n  return position\n}\n", "export function noop() {}\n\n/**\n * TODO Beware that only optimized cases are covered in tests =)\n * TODO Need to cover general case as well\n *\n * @param fns\n */\nexport function chainFns(...fns: Function[]): Function {\n  if (fns.length === 0) return noop\n  if (fns.length === 1) return fns[0]\n\n  return function (this: any) {\n    var result\n    for (let fn of fns) {\n      result = fn.apply(this, arguments) || result\n    }\n    return result\n  }\n}\n\n/**\n * Expects a simple value or 2D vector (an array with 2 elements) and\n * always returns 2D vector. If simple value is passed, returns a\n * vector with this value as both coordinates.\n *\n * @param value\n */\nexport function ensureVector<T>(value: T | [T, T] | undefined, fallback?: T | [T, T]): [T, T] {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected')\n    }\n    value = fallback\n  }\n\n  if (Array.isArray(value)) return value\n  return [value, value]\n}\n\n/**\n * Helper for defining a default value\n *\n * @param value\n * @param fallback\n */\nexport function assignDefault<T extends Object>(value: Partial<T> | undefined, fallback: T): T {\n  return Object.assign({}, fallback, value || {})\n}\n\n/**\n * Resolves getters (functions) by calling them\n * If simple value is given it just passes through\n *\n * @param v\n */\nexport function valueFn<T>(v: T | ((...args: any[]) => T), ...args: any[]): T {\n  if (typeof v === 'function') {\n    // @ts-ignore\n    return v(...args)\n  } else {\n    return v\n  }\n}\n", "export type Resolver = (x: any, key: string, obj: object) => any\nexport type ResolverMap = { [k: string]: Resolver | ResolverMap | boolean }\n\nexport function resolveWith<T extends { [k: string]: any }, V extends { [k: string]: any }>(\n  config: Partial<T> = {},\n  resolvers: ResolverMap\n): V {\n  const result: any = {}\n\n  for (const [key, resolver] of Object.entries(resolvers))\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config)\n        break\n      case 'object':\n        result[key] = resolveWith(config[key], resolver)\n        break\n      case 'boolean':\n        if (resolver) result[key] = config[key]\n        break\n    }\n\n  return result\n}\n", "import { Vector2, WebKitGestureEvent, DomEvents } from '../types'\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport function supportsTouchEvents(): boolean {\n  return typeof window !== 'undefined' && 'ontouchstart' in window\n}\n\nexport function supportsPointerEvents(): boolean {\n  return typeof window !== 'undefined' && 'onpointerdown' in window\n}\n\nfunction getEventTouches(event: PointerEvent | React.PointerEvent | TouchEvent | React.TouchEvent) {\n  if ('pointerId' in event) return null\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches\n}\n\nexport function getTouchIds(event: TouchEvent | React.TouchEvent): number[] {\n  return Array.from(getEventTouches(event)!).map(t => t.identifier)\n}\n\nexport function getGenericEventData(event: DomEvents) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const { shiftKey, altKey, metaKey, ctrlKey } = event as any // TODO check if this might create some overrides?\n  return { buttons, shiftKey, altKey, metaKey, ctrlKey }\n}\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(\n  event: TouchEvent | React.TouchEvent | React.PointerEvent | PointerEvent,\n  transform = identity\n): Vector2 {\n  const touchEvents = getEventTouches(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return transform([clientX, clientY])\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventValues(\n  event: React.TouchEvent | TouchEvent,\n  pointerIds: [number, number],\n  transform = identity\n) {\n  const [A, B] = Array.from(event.touches).filter(t => pointerIds.includes(t.identifier))\n\n  if (!A || !B) throw Error(`The event doesn't have two pointers matching the pointerIds`)\n\n  const dx = B.clientX - A.clientX\n  const dy = B.clientY - A.clientY\n  const cx = (B.clientX + A.clientX) / 2\n  const cy = (B.clientY + A.clientY) / 2\n\n  // const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  const distance = Math.hypot(dx, dy)\n  // FIXME rotation has inconsistant values so we're not using it atm\n  // const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI\n  const values: Vector2 = transform([distance, angle])\n  const origin: Vector2 = transform([cx, cy])\n\n  return { values, origin }\n}\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: React.UIEvent | UIEvent, transform = identity): Vector2 {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0])\n}\n\n// wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\nconst LINE_HEIGHT = 40\nconst PAGE_HEIGHT = 800\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: React.WheelEvent | WheelEvent, transform = identity): Vector2 {\n  let { deltaX, deltaY, deltaMode } = event\n  // normalize wheel values, especially for Firefox\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT\n    deltaY *= LINE_HEIGHT\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT\n    deltaY *= PAGE_HEIGHT\n  }\n  return transform([deltaX, deltaY])\n}\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent, transform = identity): Vector2 {\n  return transform([event.scale, event.rotation])\n}\n", "import { ensureVector, assignDefault, valueFn } from './utils'\nimport { resolveWith } from './resolveOptionsWith'\n\nimport {\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n  Vector2,\n  Bounds,\n  StateKey,\n  State,\n  CoordinatesKey,\n  DistanceAngleKey,\n} from '../types'\nimport { supportsTouchEvents, supportsPointerEvents } from './event'\n\nexport const DEFAULT_DRAG_DELAY = 180\nexport const DEFAULT_RUBBERBAND = 0.15\nexport const DEFAULT_SWIPE_VELOCITY = 0.5\nexport const DEFAULT_SWIPE_DISTANCE = 50\nexport const DEFAULT_SWIPE_DURATION = 250\n\nconst InternalGestureOptionsNormalizers = {\n  threshold(value: number | Vector2 = 0) {\n    return ensureVector(value)\n  },\n\n  rubberband(value: number | boolean | Vector2 = 0): Vector2 {\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND)\n      case false:\n        return ensureVector(0)\n      default:\n        return ensureVector(value)\n    }\n  },\n\n  enabled(value = true) {\n    return value\n  },\n\n  triggerAllEvents(value = false) {\n    return value\n  },\n\n  initial(value = 0) {\n    if (typeof value === 'function') return value\n    return ensureVector(value)\n  },\n\n  transform: true,\n}\n\nconst InternalCoordinatesOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n  axis: true,\n  lockDirection(value = false) {\n    return value\n  },\n  bounds(value: Bounds | ((state?: State) => Bounds) = {}) {\n    if (typeof value === 'function')\n      return (state?: State) => InternalCoordinatesOptionsNormalizers.bounds(value(state))\n\n    const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value\n\n    return [\n      [left, right],\n      [top, bottom],\n    ]\n  },\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement\n\nconst InternalGenericOptionsNormalizers = {\n  enabled(value = true) {\n    return value\n  },\n  domTarget: true,\n  window(value = isBrowser ? window : undefined) {\n    return value\n  },\n  eventOptions({ passive = true, capture = false } = {}) {\n    return { passive, capture }\n  },\n  transform: true,\n}\n\nconst InternalDistanceAngleOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n\n  bounds(_value: undefined, _key: string, { distanceBounds = {}, angleBounds = {} }) {\n    const _distanceBounds = (state?: State) => {\n      const D = assignDefault(valueFn(distanceBounds, state), { min: -Infinity, max: Infinity })\n      return [D.min, D.max]\n    }\n\n    const _angleBounds = (state?: State) => {\n      const A = assignDefault(valueFn(angleBounds, state), { min: -Infinity, max: Infinity })\n      return [A.min, A.max]\n    }\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function')\n      return [_distanceBounds(), _angleBounds()]\n\n    return (state?: State) => [_distanceBounds(state), _angleBounds(state)]\n  },\n}\n\nconst InternalDragOptionsNormalizers = {\n  ...InternalCoordinatesOptionsNormalizers,\n\n  useTouch(value = false) {\n    const supportsTouch = supportsTouchEvents()\n    const supportsPointer = supportsPointerEvents()\n    if (value && supportsTouch) return true\n    if (supportsTouch && !supportsPointer) return true\n    return false\n  },\n  experimental_preventWindowScrollY(value = false) {\n    return value\n  },\n  threshold(\n    this: InternalDragOptions,\n    v: number | Vector2 | undefined,\n    _k: string,\n    { filterTaps = false, lockDirection = false, axis = undefined }\n  ) {\n    const A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0) as Vector2\n    this.filterTaps = filterTaps\n    return A\n  },\n\n  swipeVelocity(v: number | Vector2 = DEFAULT_SWIPE_VELOCITY) {\n    return ensureVector(v)\n  },\n  swipeDistance(v: number | Vector2 = DEFAULT_SWIPE_DISTANCE) {\n    return ensureVector(v)\n  },\n  swipeDuration(value = DEFAULT_SWIPE_DURATION) {\n    return value\n  },\n  delay(value: number | boolean = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY\n      case false:\n        return 0\n      default:\n        return value\n    }\n  },\n}\n\nexport function getInternalGenericOptions(config: GenericOptions = {}): InternalGenericOptions {\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith<GenericOptions, InternalGenericOptions>(config, InternalGenericOptionsNormalizers)\n}\n\nexport function getInternalGestureOptions<T extends StateKey>(\n  config: GestureOptions<T> = {}\n): InternalGestureOptions<T> {\n  return resolveWith<GestureOptions<T>, InternalGestureOptions<T>>(config, InternalGestureOptionsNormalizers)\n}\n\nexport function getInternalCoordinatesOptions<T extends CoordinatesKey>(\n  config: CoordinatesConfig<T> = {}\n): InternalCoordinatesOptions<T> {\n  return resolveWith<CoordinatesConfig<T>, InternalCoordinatesOptions<T>>(config, InternalCoordinatesOptionsNormalizers)\n}\n\nexport function getInternalDistanceAngleOptions<T extends DistanceAngleKey>(\n  config: DistanceAngleConfig<T> = {}\n): InternalDistanceAngleOptions<T> {\n  return resolveWith<DistanceAngleConfig<T>, InternalDistanceAngleOptions<T>>(\n    config,\n    InternalDistanceAngleOptionsNormalizers\n  )\n}\n\nexport function getInternalDragOptions(config: DragConfig = {}): InternalDragOptions {\n  return resolveWith<DragConfig, InternalDragOptions>(config, InternalDragOptionsNormalizers)\n}\n", "import {\n  InternalConfig,\n  UseMoveConfig,\n  UseHoverConfig,\n  UseDragConfig,\n  UsePinchConfig,\n  UseScrollConfig,\n  UseWheelConfig,\n} from '../types'\n\nimport {\n  getInternalGenericOptions,\n  getInternalCoordinatesOptions,\n  getInternalDragOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\n\nimport { UseGestureConfig } from '../types'\n\nexport function _buildMoveConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseMoveConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.move = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildHoverConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseHoverConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.hover = { enabled: true, ...rest }\n  return opts\n}\n\nexport function _buildDragConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseDragConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.drag = getInternalDragOptions(rest)\n  return opts\n}\n\nexport function _buildPinchConfig({ domTarget, eventOptions, window, enabled, ...rest }: UsePinchConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.pinch = getInternalDistanceAngleOptions(rest)\n  return opts\n}\n\nexport function _buildScrollConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseScrollConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.scroll = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildWheelConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseWheelConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.wheel = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function buildComplexConfig(config: UseGestureConfig = {}, actions: Set<string> = new Set()) {\n  const { drag, wheel, move, scroll, pinch, hover, eventOptions, window, transform, domTarget, enabled } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions({\n    domTarget,\n    eventOptions,\n    transform,\n    window,\n    enabled,\n  })\n\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag)\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move)\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  if (actions.has('onHover')) mergedConfig.hover = { enabled: true, ...hover }\n\n  return mergedConfig\n}\n", "import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2, DragState, PinchState } from '../types'\n\nfunction getInitial<T>(mixed: T): T & CommonGestureState {\n  return {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [\n      [-Infinity, Infinity],\n      [-Infinity, Infinity],\n    ],\n    _threshold: [0, 0],\n    _lastEventType: undefined,\n    _dragStarted: false,\n    _dragPreventScroll: false,\n    _dragIsTap: true,\n    _dragDelayed: false,\n    event: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n    ...mixed,\n  }\n}\n\nexport function getInitialState(): State {\n  const shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n    locked: false,\n  }\n\n  const drag = getInitial<DragState & Coordinates>({\n    _pointerId: undefined,\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n    tap: false,\n    swipe: [0, 0],\n  })\n\n  const pinch = getInitial<DistanceAngle & PinchState>({\n    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]\n    _pointerIds: [],\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    // @ts-expect-error origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0,\n  })\n\n  const wheel = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const move = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const scroll = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  return { shared, drag, pinch, wheel, move, scroll }\n}\n", "import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  IngKey,\n  InternalConfig,\n  GestureKey,\n  GestureState,\n  EventTypes,\n  PartialGestureState,\n  Vector2,\n  FullGestureState,\n  RecognizerClass,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { rubberbandIfOutOfBounds } from '../utils/rubberband'\nimport { subV, addV, sign } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\nexport const RecognizersMap = new Map<GestureKey, RecognizerClass>()\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * @private\n * Recognizer abstract class.\n */\nexport default abstract class Recognizer<T extends StateKey = StateKey> {\n  abstract readonly ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n  abstract readonly stateKey: T\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(readonly controller: Controller, readonly args: any[] = []) {\n    this.controller = controller\n    this.args = args\n  }\n\n  // Returns the gesture config\n  get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  get transform() {\n    return this.config.transform || this.controller.config.transform || identity\n  }\n\n  // Convenience method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Convenience method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  protected abstract getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T>\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  protected abstract mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'>\n\n  public abstract addBindings(bindings: any): void\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2): PartialGestureState<T> {\n    const { rubberband } = this.config\n\n    const {\n      _bounds,\n      _initial,\n      _active,\n      _intentional: wasIntentional,\n      lastOffset,\n      movement: prevMovement,\n      _threshold: _T,\n    } = this.state\n    const M = this.getInternalMovement(values, this.state)\n\n    const i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0]\n    const i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1]\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], M)\n    if (intentionalityCheck._blocked) {\n      return { ...intentionalityCheck, _movement: M, delta: [0, 0] }\n    }\n\n    const _intentional = intentionalityCheck._intentional!\n    const _movement = M\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement: Vector2 = [\n      _intentional[0] !== false ? M[0] - _intentional[0] : 0,\n      _intentional[1] !== false ? M[1] - _intentional[1] : 0,\n    ]\n\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband)\n\n    return {\n      ...intentionalityCheck,\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial,\n      _movement,\n      movement,\n      values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n  }\n\n  /**\n   * Fires the gesture handler\n   */\n  protected fireGestureHandler = (forceFlag: boolean = false): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't fire the handler.\n    if (!forceFlag && !this.state.intentional && !this.config.triggerAllEvents) return null\n\n    if (this.state.intentional) {\n      const prev_active = this.state.active\n      const next_active = this.state._active\n\n      this.state.active = next_active\n      this.state.first = next_active && !prev_active\n      this.state.last = prev_active && !next_active\n\n      this.controller.state.shared[this.ingKey] = next_active // Sets dragging, pinching, etc. to the gesture active state\n    }\n    const touches = this.controller.pointerIds.size || this.controller.touchIds.size\n    const down = this.controller.state.shared.buttons > 0 || touches > 0\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n      locked: !!document.pointerLockElement,\n      touches,\n      down,\n    } as FullGestureState<T>\n\n    // @ts-expect-error\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    return state\n  }\n}\n\n//--------------------------------------------\n\nfunction getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold\n  } else {\n    return false\n  }\n}\n\nfunction computeRubberband(bounds: [Vector2, Vector2], [Vx, Vy]: Vector2, [Rx, Ry]: Vector2): Vector2 {\n  const [[X1, X2], [Y1, Y2]] = bounds\n\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)]\n}\n\n/**\n * Returns a generic, common payload for all gestures from an event.\n */\nexport function getGenericPayload<T extends StateKey>(\n  { state }: Recognizer<T>,\n  event: EventTypes[T],\n  isStartEvent?: boolean\n) {\n  const { timeStamp, type: _lastEventType } = event\n  const previous = state.values\n  const elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime!\n  return { _lastEventType, event, timeStamp, elapsedTime, previous }\n}\n\n/**\n * Returns the reinitialized start state for the gesture.\n * Should be common to all gestures.\n */\nexport function getStartGestureState<T extends StateKey>(\n  { state, config, stateKey, args, transform }: Recognizer<T>,\n  values: Vector2,\n  event: EventTypes[T],\n  initial?: Vector2\n) {\n  const offset = state.offset\n  const startTime = event.timeStamp\n\n  const { initial: initialFn, bounds, threshold } = config\n\n  // the _threshold is the difference between a [0,0] offset converted to\n  // its new space coordinates\n  const _threshold = subV(transform(threshold), transform([0, 0])).map(Math.abs)\n\n  const _state = {\n    ...getInitialState()[stateKey],\n    _active: true,\n    args,\n    values,\n    initial: initial ?? values,\n    _threshold,\n    offset,\n    lastOffset: offset,\n    startTime,\n  }\n\n  return { ..._state, _initial: valueFn(initialFn, _state), _bounds: valueFn(bounds, _state) }\n}\n", "import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n  RecognizerClass,\n} from './types'\nimport { supportsTouchEvents, supportsGestureEvents, getTouchIds } from './utils/event'\nimport { getInitialState } from './utils/state'\nimport { chainFns } from './utils/utils'\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n */\nexport default class Controller {\n  public nativeRefs!: any\n  public config!: InternalConfig\n  public handlers!: InternalHandlers\n  public state: State // state for all gestures\n  public timeouts: { [stateKey in StateKey]?: number } // tracks timeouts of debounced gestures\n  public domListeners: [string, Fn][] // when config.domTarget is set, we attach events directly to the dom\n  public windowListeners: { [stateKey in StateKey]?: [string, Function][] } // keeps track of window listeners added by gestures (drag only at the moment)\n\n  public pointerIds = new Set<number>() // register Pointer Events pointerIds\n  public touchIds = new Set<number>() // register Touch Events identifiers\n  public supportsTouchEvents = supportsTouchEvents()\n  public supportsGestureEvents = supportsGestureEvents()\n\n  constructor(private classes: Set<RecognizerClass>) {\n    this.classes = classes\n    this.state = getInitialState()\n    this.timeouts = {}\n    this.domListeners = []\n    this.windowListeners = {}\n  }\n\n  public bind = (...args: any[]) => {\n    const bindings: { [key: string]: Function[] } = {}\n\n    for (let RecognizerClass of this.classes) new RecognizerClass(this, args).addBindings(bindings)\n\n    // // we also add event bindings for native handlers\n    for (let eventKey in this.nativeRefs) {\n      addBindings(bindings, eventKey, (event: any) => this.nativeRefs[eventKey]({ ...this.state.shared, event, args }))\n    }\n\n    if (this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(this, bindings)\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(this, bindings)\n    }\n  }\n\n  public effect = () => {\n    if (this.config.domTarget) this.bind()\n    return this.clean\n  }\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    const domTarget = getDomTargetFromConfig(this.config)\n    const { eventOptions } = this.config\n    if (domTarget) removeListeners(domTarget, takeAll(this.domListeners), eventOptions)\n    Object.values(this.timeouts).forEach(clearTimeout)\n    clearAllWindowListeners(this)\n  }\n}\n\nexport function addEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  if ('pointerId' in event) {\n    controller.pointerIds.add(event.pointerId)\n  } else {\n    controller.touchIds = new Set(getTouchIds(event))\n  }\n}\n\nexport function removeEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  if ('pointerId' in event) {\n    controller.pointerIds.delete(event.pointerId)\n  } else {\n    getTouchIds(event).forEach(id => controller.touchIds.delete(id))\n  }\n}\n\nexport function clearAllWindowListeners(controller: Controller) {\n  const {\n    config: { window: el, eventOptions },\n    windowListeners,\n  } = controller\n  if (!el) return\n\n  for (let stateKey in windowListeners) {\n    const handlers = windowListeners[stateKey as StateKey]\n    removeListeners(el, handlers, eventOptions)\n  }\n\n  controller.windowListeners = {}\n}\n\nexport function clearWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  delete windowListeners[stateKey]\n}\n\nexport function updateWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  listeners: [string, Fn][] = [],\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  addListeners(config.window, (windowListeners[stateKey] = listeners), options)\n}\n\nfunction updateDomListeners({ config, domListeners }: Controller, bindings: { [key: string]: Function[] }) {\n  const domTarget = getDomTargetFromConfig(config)\n  if (!domTarget) throw new Error('domTarget must be defined')\n  const { eventOptions } = config\n\n  removeListeners(domTarget, takeAll(domListeners), eventOptions)\n\n  for (let [key, fns] of Object.entries(bindings)) {\n    const name = key.slice(2).toLowerCase()\n    domListeners.push([name, chainFns(...fns)])\n  }\n\n  addListeners(domTarget, domListeners, eventOptions)\n}\n\nfunction getPropsListener({ config }: Controller, bindings: { [key: string]: Function[] }) {\n  const props: ReactEventHandlers = {}\n  const captureString = config.eventOptions.capture ? 'Capture' : ''\n  for (let [event, fns] of Object.entries(bindings)) {\n    const fnsArray = Array.isArray(fns) ? fns : [fns]\n    const key = (event + captureString) as ReactEventHandlerKey\n    props[key] = chainFns(...(fnsArray as Fn[]))\n  }\n  return props\n}\n\nfunction takeAll<T>(array: Array<T> = []) {\n  return array.splice(0, array.length)\n}\n\nfunction getDomTargetFromConfig({ domTarget }: InternalConfig) {\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n}\n\n/**\n * bindings is an object which keys match ReactEventHandlerKeys.\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n * that key.\n */\nexport function addBindings(bindings: any, name: string, fn: Fn): void {\n  if (!bindings[name]) bindings[name] = []\n  bindings[name]!.push(fn)\n}\n\nfunction addListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.addEventListener(eventName, eventHandler, options)\n  }\n}\n\nfunction removeListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.removeEventListener(eventName, eventHandler, options)\n  }\n}\n", "/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  GenericOptions,\n  RecognizerClass,\n  NativeHandlers,\n} from '../types'\n\n/**\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param handlers\n * @param classes\n * @param config\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  config: InternalConfig,\n  nativeHandlers: Partial<NativeHandlers> = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const classes = resolveClasses(handlers)\n\n  const controller = React.useMemo(() => new Controller(classes), [])\n  controller!.config = config\n  controller!.handlers = handlers\n  controller!.nativeRefs = nativeHandlers\n\n  React.useEffect(controller.effect, [])\n\n  // @ts-ignore\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget\n  // @ts-ignore\n  return controller.bind\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Deprecation notice: When the \\`domTarget\\` option is specified, you don't need to write \\`useEffect(bind, [bind])\\` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when \\`domTarget\\` is provided, therefore your code will break if you try to call \\`useEffect\\`.`\n    )\n  }\n}\n\nfunction resolveClasses(internalHandlers: Partial<InternalHandlers>) {\n  const classes = new Set<RecognizerClass>()\n\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag')!)\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel')!)\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll')!)\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move')!)\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch')!)\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover')!)\n\n  return classes\n}\n", "import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into account)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return { _intentional, axis: this.state.axis } as PartialGestureState<T>\n    }\n    const [absX, absY] = _movement.map(Math.abs)\n    const axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n    if (!this.config.axis && !this.config.lockDirection) return { _intentional, _blocked: false, axis } as any\n    if (!axis) return { _intentional: [false, false], _blocked: false, axis } as any\n    if (!!this.config.axis && axis !== this.config.axis) return { _intentional, _blocked: true, axis } as any\n    _intentional![axis === 'x' ? 1 : 0] = false\n    return { _intentional, _blocked: false, axis } as any\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    if (!state._blocked) {\n      const dt = event.timeStamp - this.state.timeStamp!\n      Object.assign(state, calculateAllKinematics(state.movement!, state.delta!, dt))\n    }\n    return state\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { xy: state.values, vxvy: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n", "import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, sign } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, updateWindowListeners, clearWindowListeners, addEventIds, removeEventIds } from '../Controller'\n\nexport const TAP_DISTANCE_THRESHOLD = 3\nexport const SWIPE_MAX_ELAPSED_TIME = 220\n\nfunction persistEvent(event: React.PointerEvent | PointerEvent) {\n  'persist' in event && typeof event.persist === 'function' && event.persist()\n}\n\nexport class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  readonly ingKey = 'dragging'\n  readonly stateKey = 'drag'\n\n  // TODO add back when setPointerCapture is widely wupported\n  // https://caniuse.com/#search=setPointerCapture\n  private setPointerCapture = (event: React.PointerEvent | PointerEvent) => {\n    // don't perform pointere capture when user wants to use touch events or\n    // when a pointerLockElement exists as this would throw an error\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { target, pointerId } = event\n    if (target && 'setPointerCapture' in target) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.addEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      // @ts-expect-error\n      target.setPointerCapture(pointerId)\n    }\n    this.updateGestureState({ _dragTarget: target, _dragPointerId: pointerId })\n  }\n\n  private releasePointerCapture = () => {\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { _dragTarget, _dragPointerId } = this.state\n    if (_dragPointerId && _dragTarget && 'releasePointerCapture' in _dragTarget) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.removeEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      if (!('hasPointerCapture' in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId))\n        try {\n          _dragTarget.releasePointerCapture(_dragPointerId)\n        } catch (e) {}\n    }\n  }\n\n  private preventScroll = (event: TouchEvent) => {\n    if (this.state._dragPreventScroll && event.cancelable) {\n      event.preventDefault()\n    }\n  }\n\n  private getEventId = (event: any): number => {\n    if (this.config.useTouch) return event.changedTouches[0].identifier\n    return event.pointerId\n  }\n\n  private isValidEvent = (event: any) => {\n    // if we were using pointer events only event.isPrimary === 1 would suffice\n    return this.state._pointerId === this.getEventId(event)\n  }\n\n  private shouldPreventWindowScrollY =\n    this.config.experimental_preventWindowScrollY && this.controller.supportsTouchEvents\n\n  private setUpWindowScrollDetection = (event: React.PointerEvent | PointerEvent) => {\n    persistEvent(event)\n    // we add window listeners that will prevent the scroll when the user has started dragging\n    updateWindowListeners(\n      this.controller,\n      this.stateKey,\n      [\n        ['touchmove', this.preventScroll],\n        ['touchend', this.clean.bind(this)],\n        ['touchcancel', this.clean.bind(this)],\n      ],\n      { passive: false }\n    )\n    this.setTimeout(this.startDrag.bind(this), 250, event)\n  }\n\n  private setUpDelayedDragTrigger = (event: React.PointerEvent | PointerEvent) => {\n    this.state._dragDelayed = true\n    persistEvent(event)\n    this.setTimeout(this.startDrag.bind(this), this.config.delay, event)\n  }\n\n  private setStartState = (event: React.PointerEvent | PointerEvent) => {\n    const values = getPointerEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerId: this.getEventId(event), // setting pointerId locks the gesture to this specific event\n    })\n\n    this.updateGestureState(this.getMovement(values))\n  }\n\n  onDragStart = (event: React.PointerEvent | PointerEvent): void => {\n    addEventIds(this.controller, event)\n    if (!this.enabled || this.state._active) return\n\n    this.setStartState(event)\n    this.setPointerCapture(event as PointerEvent)\n\n    if (this.shouldPreventWindowScrollY) this.setUpWindowScrollDetection(event)\n    else if (this.config.delay > 0) this.setUpDelayedDragTrigger(event)\n    else this.startDrag(event, true) // we pass the values to the startDrag event\n  }\n\n  startDrag(event: React.PointerEvent | PointerEvent, onDragIsStart: boolean = false) {\n    // startDrag can happen after a timeout, so we need to check if the gesture is still active\n    // as the user might have lift up the pointer in between.\n\n    if (\n      // if the gesture isn't active (probably means)\n      !this.state._active ||\n      // if the drag has already started we should ignore subsequent attempts\n      this.state._dragStarted\n    )\n      return\n\n    if (!onDragIsStart) this.setStartState(event)\n    this.updateGestureState({ _dragStarted: true, _dragPreventScroll: true, cancel: this.onCancel })\n    this.clearTimeout()\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: PointerEvent): void => {\n    if (\n      // if the gesture was canceled or\n      this.state.canceled ||\n      // if onDragStart wasn't fired or\n      !this.state._active ||\n      // if the event pointerId doesn't match the one that initiated the drag\n      !this.isValidEvent(event) ||\n      // if the event has the same timestamp as the previous event\n      // note that checking type equality is ONLY for tests ¯\\_(ツ)_/¯\n      (this.state._lastEventType === event.type && event.timeStamp === this.state.timeStamp)\n    )\n      return\n\n    let values\n\n    if (document.pointerLockElement) {\n      const { movementX, movementY } = event\n      values = addV(this.transform([movementX, movementY]), this.state.values)\n    } else values = getPointerEventValues(event, this.transform)\n\n    const kinematics = this.getKinematics(values, event)\n\n    // if startDrag hasn't fired\n    if (!this.state._dragStarted) {\n      // If the gesture isn't active then respond to the event only if\n      // it's been delayed via the `delay` option, in which case start\n      // the gesture immediately.\n      if (this.state._dragDelayed) {\n        this.startDrag(event)\n        return\n      }\n      // if the user wants to prevent vertical window scroll when user starts dragging\n      if (this.shouldPreventWindowScrollY) {\n        if (!this.state._dragPreventScroll && kinematics.axis) {\n          // if the user is dragging horizontally then we should allow the drag\n          if (kinematics.axis === 'x') {\n            this.startDrag(event)\n          } else {\n            this.state._active = false\n            return\n          }\n        } else return\n      } else return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    const genericPayload = getGenericPayload(this, event)\n\n    // This verifies if the drag can be assimilated to a tap by checking\n    // if the real distance of the drag (ie not accounting for the threshold) is\n    // greater than the TAP_DISTANCE_THRESHOLD.\n    const realDistance = calculateDistance(kinematics._movement!)\n    let { _dragIsTap } = this.state\n    if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD) _dragIsTap = false\n\n    this.updateGestureState({ ...genericPayload, ...kinematics, _dragIsTap })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: PointerEvent): void => {\n    removeEventIds(this.controller, event)\n\n    // if the event pointerId doesn't match the one that initiated the drag\n    // we don't want to end the drag\n    if (!this.isValidEvent(event)) return\n    this.clean()\n\n    // if the gesture is no longer active (ie canceled)\n    // don't do anything\n    if (!this.state._active) return\n    this.state._active = false\n\n    const tap = this.state._dragIsTap\n    const [vx, vy] = this.state.velocities\n    const [mx, my] = this.state.movement\n    const [ix, iy] = this.state._intentional\n    const [svx, svy] = this.config.swipeVelocity\n    const [sx, sy] = this.config.swipeDistance\n    const sd = this.config.swipeDuration\n\n    const endState = {\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    }\n\n    const swipe: [number, number] = [0, 0]\n\n    if (endState.elapsedTime < sd) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateSharedState({ buttons: 0 })\n    this.updateGestureState({ ...endState, tap, swipe })\n    this.fireGestureHandler(this.config.filterTaps && tap === true)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._dragStarted = false\n    this.releasePointerCapture()\n    clearWindowListeners(this.controller, this.stateKey)\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ canceled: true, _active: false })\n    this.updateSharedState({ buttons: 0 })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n\n  onClick = (event: React.UIEvent | UIEvent): void => {\n    if (!this.state._dragIsTap) event.stopPropagation()\n  }\n\n  addBindings(bindings: any): void {\n    if (this.config.useTouch) {\n      addBindings(bindings, 'onTouchStart', this.onDragStart)\n      addBindings(bindings, 'onTouchMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onTouchEnd', this.onDragEnd)\n      addBindings(bindings, 'onTouchCancel', this.onDragEnd)\n    } else {\n      addBindings(bindings, 'onPointerDown', this.onDragStart)\n      addBindings(bindings, 'onPointerMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onPointerUp', this.onDragEnd)\n      addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n    }\n\n    if (this.config.filterTaps) {\n      const handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture'\n      addBindings(bindings, handler, this.onClick)\n    }\n  }\n}\n", "/**\n * Inlined from https://github.com/alexreardon/memoize-one\n */\n\nexport type EqualityFn = (newArgs: any[], lastArgs: any[]) => boolean\n\nexport default function memoizeOne<ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>>(\n  resultFn: ResultFn,\n  isEqual: EqualityFn\n): ResultFn {\n  let lastThis: unknown\n  let lastArgs: unknown[] = []\n  let lastResult: ReturnType<ResultFn>\n  let calledOnce: boolean = false\n\n  function memoized(this: unknown, ...newArgs: unknown[]): ReturnType<ResultFn> {\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult\n    }\n\n    lastResult = resultFn.apply(this, newArgs)\n    calledOnce = true\n    lastThis = this\n    lastArgs = newArgs\n    return lastResult\n  }\n\n  return memoized as ResultFn\n}\n", "/**\n * Taken from https://github.com/FormidableLabs/react-fast-compare\n *\n * Dropped comments and ArrayBuffer handling\n */\n\nfunction equal(a: any, b: any): boolean {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false\n\n    let length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      if (length !== b.length) return false\n      for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false\n      return true\n    }\n\n    let it\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false\n      return true\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      return true\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf()\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false\n\n    for (i = length; i-- !== 0; ) {\n      if (keys[i] === '_owner' && a.$$typeof) continue\n      if (!equal(a[keys[i]], b[keys[i]])) return false\n    }\n    return true\n  }\n\n  // true if both NaN, false otherwise — NaN !== NaN → true\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport default function isEqual(a: any, b: any) {\n  try {\n    return equal(a, b)\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      // eslint-disable-next-line no-console\n      console.warn('react-fast-compare cannot handle circular refs')\n      return false\n    }\n    throw error\n  }\n}\n", "import { UseDragConfig, Handler, EventTypes } from '../types'\nimport { _buildDragConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Drag hook.\n *\n * @param handler - the function fired every time the drag gesture updates\n * @param [config={}] - the config object including generic options and drag options\n */\nexport function useDrag<K = EventTypes['drag']>(handler: Handler<'drag', K>, config: UseDragConfig | {} = {}) {\n  RecognizersMap.set('drag', DragRecognizer)\n  const buildDragConfig = useRef<any>()\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoize(_buildDragConfig, isEqual)\n  }\n  return useRecognizers<UseDragConfig>({ drag: handler }, buildDragConfig.current(config))\n}\n", "import Recognizer from './Recognizer'\nimport { calculateAllKinematics, sign, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  protected getInternalMovement(values: [number, number?], state: GestureState<T>): Vector2 {\n    const prev_a = state.values[1]\n    // not be defined if ctrl+wheel is used for zoom only\n    let [d, a = prev_a] = values\n\n    let delta_a = a - prev_a\n    let next_turns = state.turns\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a)\n    return subV([d, a - 360 * next_turns], state.initial)\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    const turns = (values[1] - state._movement![1] - this.state.initial[1]) / 360\n    const dt = event.timeStamp - this.state.timeStamp!\n    const { distance, velocity, ...kinematics } = calculateAllKinematics(state.movement!, state.delta!, dt)\n    return { turns, ...state, ...kinematics }\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { da: state.values, vdva: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n\n/**\n * @param dangle is a small change of variable on \"lifting\" of the circle.\n * It's expected to be small and cannot be greater than 270 or under -270\n */\nexport function fixContinuity(dangle: number) {\n  dangle -= Math.round(dangle / 360) * 360\n  if (dangle > 270) return dangle - 360\n  if (dangle < -270) return dangle + 360\n  return dangle\n}\n", "import DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { Vector2, WebKitGestureEvent } from '../types'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventValues,\n  getWheelEventValues,\n  getWebkitGestureEventValues,\n  getTouchIds,\n} from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, addEventIds, removeEventIds } from '../Controller'\n\nconst ZOOM_CONSTANT = 7\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\nexport class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  readonly ingKey = 'pinching'\n  readonly stateKey = 'pinch'\n\n  onPinchStart = (event: React.TouchEvent | TouchEvent) => {\n    addEventIds(this.controller, event)\n    const touchIds = this.controller.touchIds\n\n    if (!this.enabled) return\n\n    if (this.state._active) {\n      // check that the pointerIds that initiated the gesture\n      // are still enabled. This is useful for when the page\n      // loses track of the pointers (minifying gesture on iPad).\n      if (this.state._pointerIds.every(id => touchIds.has(id))) return\n      // something was wrong with the pointers but we let it go.\n    }\n    // until we reach two fingers on the target don't react\n    if (touchIds.size < 2) return\n    const _pointerIds = Array.from(touchIds).slice(0, 2) as [number, number]\n\n    const { values, origin } = getTwoTouchesEventValues(event, _pointerIds, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerIds,\n      cancel: this.onCancel,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: React.TouchEvent | TouchEvent): void => {\n    const { canceled, _active } = this.state\n    if (\n      canceled ||\n      !_active ||\n      // if the event has the same timestamp as the previous event\n      event.timeStamp === this.state.timeStamp\n    )\n      return\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    try {\n      const { values, origin } = getTwoTouchesEventValues(event, this.state._pointerIds, this.transform)\n      const kinematics = this.getKinematics(values, event)\n\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...kinematics,\n        origin,\n      })\n\n      this.fireGestureHandler()\n    } catch (e) {\n      this.onPinchEnd(event)\n    }\n  }\n\n  onPinchEnd = (event: React.TouchEvent | TouchEvent): void => {\n    removeEventIds(this.controller, event)\n    const pointerIds = getTouchIds(event)\n\n    // if none of the lifted pointerIds is in the state pointerIds don't do anything\n    if (this.state._pointerIds.every(id => !pointerIds.includes(id))) return\n\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ _active: false, canceled: true })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n\n    const values = getWebkitGestureEventValues(event, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n      cancel: this.onCancel,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    // this normalizes the values of the Safari's WebKitEvent by calculating\n    // the delta and then multiplying it by a constant.\n    const values = getWebkitGestureEventValues(event, this.transform)\n    values[0] =\n      (values[0] - (this.state.event as WebKitGestureEvent).scale) * WEBKIT_DISTANCE_SCALE_FACTOR + this.state.values[0]\n\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...kinematics,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n    this.fireGestureHandler()\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: React.WheelEvent | WheelEvent) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: React.WheelEvent | WheelEvent) => {\n    const [, delta_d] = getWheelEventValues(event, this.transform)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    // ZOOM_CONSTANT is based on Safari trackpad natural zooming\n    const _delta_d = -delta_d * ZOOM_CONSTANT\n    // new distance is the previous state distance added to the delta\n    const d = prev_d + _delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [_delta_d, a] as Vector2,\n    }\n  }\n\n  onWheel = (event: React.WheelEvent | WheelEvent): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: React.WheelEvent | WheelEvent): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (event.cancelable) event.preventDefault()\n    else if (process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event, this.state.values),\n      ...getGenericPayload(this, event, true),\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.cancelable) event.preventDefault()\n\n    this.updateSharedState(getGenericEventData(event))\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (\n      this.controller.config.domTarget &&\n      !this.controller.supportsTouchEvents &&\n      this.controller.supportsGestureEvents\n    ) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart)\n      addBindings(bindings, 'onGestureChange', this.onGestureChange)\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd)\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart)\n      addBindings(bindings, 'onTouchMove', this.onPinchChange)\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd)\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd)\n      addBindings(bindings, 'onWheel', this.onWheel)\n    }\n  }\n}\n", "import { UsePinchConfig, Handler, EventTypes } from '../types'\nimport { _buildPinchConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Pinch hook.\n *\n * @param handler - the function fired every time the pinch gesture updates\n * @param [config={}] - the config object including generic options and pinch options\n */\nexport function usePinch<K = EventTypes['pinch']>(handler: Handler<'pinch', K>, config: UsePinchConfig | {} = {}) {\n  RecognizersMap.set('pinch', PinchRecognizer)\n  const buildPinchConfig = useRef<any>()\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoize(_buildPinchConfig, isEqual)\n  }\n  return useRecognizers<UsePinchConfig>({ pinch: handler }, buildPinchConfig.current(config))\n}\n", "import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  readonly ingKey = 'wheeling'\n  readonly stateKey = 'wheel'\n  debounced = true\n\n  handleEvent = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return\n    if (!this.enabled) return\n\n    this.setTimeout(this.onEnd)\n    this.updateSharedState(getGenericEventData(event))\n\n    const values = addV(getWheelEventValues(event, this.transform), this.state.values)\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event, this.state.values),\n        ...getGenericPayload(this, event, true),\n      })\n\n      const movement = this.getMovement(values)\n      const geometry = calculateAllGeometry(movement.delta!)\n\n      this.updateGestureState(movement)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const movement = this.getMovement(this.state.values)\n    this.updateGestureState(movement)\n    this.updateGestureState({ _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onWheel', this.handleEvent)\n  }\n}\n", "import { UseWheelConfig, Handler, EventTypes } from '../types'\nimport { _buildWheelConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Wheel hook.\n *\n * @param handler - the function fired every time the wheel gesture updates\n * @param the config object including generic options and wheel options\n */\nexport function useWheel<K = EventTypes['wheel']>(handler: Handler<'wheel', K>, config: UseWheelConfig | {} = {}) {\n  RecognizersMap.set('wheel', WheelRecognizer)\n  const buildWheelConfig = useRef<any>()\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoize(_buildWheelConfig, isEqual)\n  }\n  return useRecognizers<UseWheelConfig>({ wheel: handler }, buildWheelConfig.current(config))\n}\n", "import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  readonly ingKey = 'moving'\n  readonly stateKey = 'move'\n\n  debounced = true\n\n  onMove = (event: React.PointerEvent | PointerEvent): void => {\n    if (!this.enabled) return\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const values = this.state.values\n    this.updateGestureState(this.getMovement(values))\n    this.updateGestureState({ velocities: [0, 0], velocity: 0, _active: false })\n    this.fireGestureHandler()\n  }\n\n  hoverTransform = () => {\n    return this.controller.config.hover!.transform || this.controller.config.transform\n  }\n\n  onPointerEnter = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const values = getPointerEventValues(event, this.hoverTransform())\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...getGenericPayload(this, event, true),\n        args: this.args,\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n    if (!this.controller.config.hover!.enabled) return\n\n    const values = getPointerEventValues(event, this.hoverTransform())\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...getGenericPayload(this, event),\n      args: this.args,\n      values,\n      active: false,\n    }\n\n    this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n  }\n\n  addBindings(bindings: any): void {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove)\n    }\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter)\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave)\n    }\n  }\n}\n", "import { UseMoveConfig, Handler, EventTypes } from '../types'\nimport { _buildMoveConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Move hook.\n *\n * @param handler - the function fired every time the move gesture updates\n * @param [config={}] - the config object including generic options and move options\n */\nexport function useMove<K = EventTypes['move']>(handler: Handler<'move', K>, config: UseMoveConfig | {} = {}) {\n  RecognizersMap.set('move', MoveRecognizer)\n  const buildMoveConfig = useRef<any>()\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoize(_buildMoveConfig, isEqual)\n  }\n  return useRecognizers<UseMoveConfig>({ move: handler }, buildMoveConfig.current(config))\n}\n", "import { Handler, UseHoverConfig, EventTypes } from '../types'\nimport { _buildHoverConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Hover hook.\n *\n * @param handler - the function fired every time the hover gesture updates\n * @param [config={}] - the config object including generic options and hover options\n */\nexport function useHover<K = EventTypes['hover']>(handler: Handler<'hover', K>, config: UseHoverConfig | {} = {}) {\n  RecognizersMap.set('hover', MoveRecognizer)\n  const buildHoverConfig = useRef<any>()\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoize(_buildHoverConfig, isEqual)\n  }\n  return useRecognizers<UseHoverConfig>({ hover: handler }, buildHoverConfig.current(config))\n}\n", "import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  readonly ingKey = 'scrolling'\n  readonly stateKey = 'scroll'\n  debounced = true\n\n  handleEvent = (event: React.UIEvent | UIEvent): void => {\n    if (!this.enabled) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const values = getScrollEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event, this.state.values),\n        ...getGenericPayload(this, event, true),\n      })\n\n      const movementDetection = this.getMovement(values)\n      const geometry = calculateAllGeometry(movementDetection.delta!)\n\n      this.updateGestureState(movementDetection)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.updateGestureState({ ...this.getMovement(this.state.values), _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onScroll', this.handleEvent)\n  }\n}\n", "import { UseScrollConfig, Handler, EventTypes } from '../types'\nimport { _buildScrollConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Scroll hook.\n *\n * @param handler - the function fired every time the scroll gesture updates\n * @param [config={}] - the config object including generic options and scroll options\n */\nexport function useScroll<K = EventTypes['scroll']>(handler: Handler<'scroll', K>, config: UseScrollConfig | {} = {}) {\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  const buildScrollConfig = useRef<any>()\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoize(_buildScrollConfig, isEqual)\n  }\n  return useRecognizers<UseScrollConfig>({ scroll: handler }, buildScrollConfig.current(config))\n}\n", "import useRecognizers from './useRecognizers'\nimport { buildComplexConfig } from './buildConfig'\nimport {\n  InternalConfig,\n  InternalHandlers,\n  UserHandlers,\n  UseGestureConfig,\n  Handlers,\n  EventTypes,\n  AnyGestureEventTypes,\n} from '../types'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\n\nexport function wrapStart(fn: Function) {\n  return function (this: any, { first }: any) {\n    if (first) fn.apply(this, arguments)\n  }\n}\n\nexport function wrapEnd(fn: Function) {\n  return function (this: any, { last }: any) {\n    if (last) fn.apply(this, arguments)\n  }\n}\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/\n\nfunction sortHandlers(handlers: object) {\n  const native: any = {}\n  const handle: any = {}\n  const actions = new Set()\n\n  for (let key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch)\n      handle[key] = (handlers as any)[key]\n    } else {\n      native[key] = (handlers as any)[key]\n    }\n  }\n\n  return [handle, native, actions]\n}\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<T extends AnyGestureEventTypes = EventTypes>(\n  _handlers: Handlers<T>,\n  config: UseGestureConfig = {}\n) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(_handlers)\n\n  RecognizersMap.set('drag', DragRecognizer)\n  RecognizersMap.set('hover', MoveRecognizer)\n  RecognizersMap.set('move', MoveRecognizer)\n  RecognizersMap.set('pinch', PinchRecognizer)\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  RecognizersMap.set('wheel', WheelRecognizer)\n\n  const mergedConfig: InternalConfig = buildComplexConfig(config, actions)\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag')\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel')\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll')\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove')\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch')\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover\n\n  return useRecognizers<UseGestureConfig>(internalHandlers, mergedConfig, nativeHandlers)\n}\n\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\ntype HandlerKey = 'onDrag' | 'onPinch' | 'onWheel' | 'onMove' | 'onScroll' | 'onHover'\nfunction includeStartEndHandlers(handlers: Partial<UserHandlers>, handlerKey: HandlerKey) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n"],
  "mappings": "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",
  "names": ["addV", "v1", "v2", "map", "v", "i", "subV", "calculateDistance", "movement", "Math", "hypot", "calculateAllGeometry", "delta", "dl", "alpha", "direction", "distance", "calculateAllKinematics", "dt", "beta", "velocity", "velocities", "sign", "x", "Number", "minMax", "value", "min", "max", "rubberband2", "constant", "pow", "rubberband", "dimension", "abs", "Infinity", "rubberbandIfOutOfBounds", "position", "noop", "chainFns", "fns", "length", "result", "fn", "apply", "arguments", "ensureVector", "fallback", "undefined", "Error", "Array", "isArray", "assignDefault", "Object", "assign", "valueFn", "args", "resolveWith", "config", "resolvers", "entries", "key", "resolver", "call", "supportsGestureEvents", "GestureEvent", "e", "supportsTouchEvents", "window", "supportsPointerEvents", "getEventTouches", "event", "type", "changedTouches", "targetTouches", "getTouchIds", "from", "t", "identifier", "getGenericEventData", "buttons", "shiftKey", "altKey", "metaKey", "ctrlKey", "identity", "xy", "getPointerEventValues", "transform", "touchEvents", "clientX", "clientY", "getTwoTouchesEventValues", "pointerIds", "touches", "filter", "includes", "A", "B", "dx", "dy", "cx", "cy", "angle", "atan2", "PI", "values", "origin", "getScrollEventValues", "currentTarget", "scrollX", "scrollY", "scrollLeft", "scrollTop", "LINE_HEIGHT", "PAGE_HEIGHT", "getWheelEventValues", "deltaX", "deltaY", "deltaMode", "getWebkitGestureEventValues", "scale", "rotation", "DEFAULT_DRAG_DELAY", "DEFAULT_RUBBERBAND", "DEFAULT_SWIPE_VELOCITY", "DEFAULT_SWIPE_DISTANCE", "DEFAULT_SWIPE_DURATION", "InternalGestureOptionsNormalizers", "threshold", "enabled", "triggerAllEvents", "initial", "InternalCoordinatesOptionsNormalizers", "axis", "lockDirection", "bounds", "state", "left", "right", "top", "bottom", "isBrowser", "document", "createElement", "InternalGenericOptionsNormalizers", "domTarget", "eventOptions", "passive", "capture", "InternalDistanceAngleOptionsNormalizers", "_value", "_key", "distanceBounds", "angleBounds", "_distanceBounds", "D", "_angleBounds", "InternalDragOptionsNormalizers", "useTouch", "supportsTouch", "supportsPointer", "experimental_preventWindowScrollY", "_k", "filterTaps", "swipeVelocity", "swipeDistance", "swipeDuration", "delay", "getInternalGenericOptions", "getInternalCoordinatesOptions", "getInternalDistanceAngleOptions", "getInternalDragOptions", "_buildMoveConfig", "rest", "opts", "move", "_buildHoverConfig", "hover", "_buildDragConfig", "drag", "_buildPinchConfig", "pinch", "_buildScrollConfig", "scroll", "_buildWheelConfig", "wheel", "buildComplexConfig", "actions", "Set", "mergedConfig", "has", "getInitial", "mixed", "_active", "_blocked", "_intentional", "_movement", "_initial", "_bounds", "_threshold", "_lastEventType", "_dragStarted", "_dragPreventScroll", "_dragIsTap", "_dragDelayed", "intentional", "offset", "lastOffset", "previous", "first", "last", "active", "timeStamp", "startTime", "elapsedTime", "cancel", "canceled", "memo", "getInitialState", "shared", "hovering", "scrolling", "wheeling", "dragging", "moving", "pinching", "down", "locked", "_pointerId", "vxvy", "tap", "swipe", "_pointerIds", "da", "vdva", "turns", "RecognizersMap", "Map", "Recognizer", "controller", "callback", "ms", "clearTimeout", "timeouts", "stateKey", "setTimeout", "forceFlag", "debounced", "clean", "prev_active", "next_active", "ingKey", "size", "touchIds", "mapStateValues", "pointerLockElement", "newMemo", "handler", "updateSharedState", "sharedState", "updateGestureState", "gestureState", "checkIntentionality", "getMovement", "wasIntentional", "prevMovement", "_T", "M", "getInternalMovement", "i0", "getIntentionalDisplacement", "i1", "intentionalityCheck", "_rubberband", "computeRubberband", "handlers", "Vx", "Vy", "Rx", "Ry", "X1", "X2", "Y1", "Y2", "getGenericPayload", "isStartEvent", "getStartGestureState", "initialFn", "_state", "Controller", "classes", "bindings", "RecognizerClass", "addBindings", "eventKey", "nativeRefs", "updateDomListeners", "getPropsListener", "bind", "getDomTargetFromConfig", "removeListeners", "takeAll", "domListeners", "forEach", "clearAllWindowListeners", "windowListeners", "addEventIds", "add", "pointerId", "removeEventIds", "id", "el", "clearWindowListeners", "options", "updateWindowListeners", "listeners", "addListeners", "name", "slice", "toLowerCase", "push", "props", "captureString", "fnsArray", "array", "splice", "current", "eventName", "eventHandler", "addEventListener", "removeEventListener", "useRecognizers", "nativeHandlers", "resolveClasses", "React", "useMemo", "useEffect", "effect", "deprecationNoticeForDomTarget", "process", "console", "warn", "internalHandlers", "get", "CoordinatesRecognizer", "absX", "absY", "getKinematics", "TAP_DISTANCE_THRESHOLD", "persistEvent", "persist", "DragRecognizer", "target", "setPointerCapture", "_dragTarget", "_dragPointerId", "hasPointerCapture", "releasePointerCapture", "cancelable", "preventDefault", "getEventId", "preventScroll", "startDrag", "setStartState", "shouldPreventWindowScrollY", "setUpWindowScrollDetection", "setUpDelayedDragTrigger", "isValidEvent", "movementX", "movementY", "kinematics", "genericEventData", "genericPayload", "realDistance", "fireGestureHandler", "vx", "vy", "mx", "my", "ix", "iy", "svx", "svy", "sx", "sy", "sd", "endState", "stopPropagation", "onDragIsStart", "onCancel", "onDragStart", "onDragChange", "onDragEnd", "onClick", "memoizeOne", "resultFn", "isEqual", "lastThis", "lastArgs", "lastResult", "calledOnce", "memoized", "newArgs", "equal", "a", "b", "constructor", "keys", "it", "next", "done", "RegExp", "source", "flags", "valueOf", "prototype", "toString", "hasOwnProperty", "Element", "$$typeof", "error", "message", "match", "useDrag", "set", "buildDragConfig", "useRef", "memoize", "DistanceAngleRecognizer", "prev_a", "d", "delta_a", "next_turns", "ZOOM_CONSTANT", "WEBKIT_DISTANCE_SCALE_FACTOR", "PinchRecognizer", "every", "onPinchEnd", "delta_d", "prev_d", "_delta_d", "wheelShouldRun", "onWheelEnd", "onWheelStart", "onWheelChange", "getWheelValuesFromEvent", "onGestureStart", "onGestureChange", "onGestureEnd", "onPinchStart", "onPinchChange", "onWheel", "usePinch", "buildPinchConfig", "WheelRecognizer", "onEnd", "geometry", "handleEvent", "useWheel", "buildWheelConfig", "MoveRecognizer", "onMoveEnd", "onMoveStart", "onMoveChange", "hoverTransform", "onMove", "onPointerEnter", "onPointerLeave", "useMove", "buildMoveConfig", "useHover", "buildHoverConfig", "ScrollRecognizer", "movementDetection", "useScroll", "buildScrollConfig", "RE_NOT_NATIVE", "sortHandlers", "native", "handle", "test", "lastMatch", "useGesture", "_handlers", "includeStartEndHandlers", "onHover", "handlerKey", "startKey", "endKey"]
}
