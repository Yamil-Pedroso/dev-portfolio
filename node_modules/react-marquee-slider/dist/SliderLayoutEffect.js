"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(require("react"));
var Child_1 = __importDefault(require("./Child"));
var util_1 = require("./util");
require("./css/slider.css");
var NESTED_UPDATE_LIMIT = 50;
var Slider = function (_a) {
    var children = _a.children, velocity = _a.velocity, scatterRandomly = _a.scatterRandomly, minScale = _a.minScale, maxScale = _a.maxScale, resetAfterTries = _a.resetAfterTries, onFinish = _a.onFinish;
    var _b = react_1.useState(0), retryAfterExceedingUpdateDepthTrigger = _b[0], setRetryAfterExceedingUpdateDepthTrigger = _b[1];
    var _c = react_1.useState(0), animationDuration = _c[0], setAnimationDuration = _c[1];
    var _d = react_1.useState(0), nestedUpdateCount = _d[0], setNestedUpdateCount = _d[1];
    var _e = react_1.useState([0, 0]), containerSize = _e[0], setContainerSize = _e[1];
    var _f = react_1.useState([]), childrenPosition = _f[0], setChildrenPosition = _f[1];
    var containerRef = react_1.useRef(null);
    var marqueeRef = react_1.useRef(null);
    var t0 = react_1.useState(performance.now())[0];
    react_1.useEffect(function () {
        if (scatterRandomly) {
            setContainerSize([containerRef.current.clientWidth, containerRef.current.clientHeight]);
        }
        setAnimationDuration(containerRef.current.clientWidth / velocity);
    }, [scatterRandomly]);
    react_1.useEffect(function () {
        if (nestedUpdateCount < NESTED_UPDATE_LIMIT) {
            if (scatterRandomly) {
                var siblings = marqueeRef.current.childNodes;
                if (siblings.length > 0) {
                    var containerRect = containerRef.current.getBoundingClientRect();
                    var childRect = siblings[siblings.length - 1].getBoundingClientRect();
                    if (util_1.outOfContainerBounds(childRect, containerRect)) {
                        setChildrenPosition(function (state) { return state.slice(0, -1); });
                        setNestedUpdateCount(nestedUpdateCount + 1);
                    }
                    else {
                        var hasOverlaps = false;
                        for (var i = 0; i + 1 < siblings.length; i++) {
                            var rect1 = siblings[i].getBoundingClientRect();
                            var rect2 = siblings[siblings.length - 1].getBoundingClientRect();
                            if (util_1.doesOverlap(rect1, rect2)) {
                                hasOverlaps = true;
                                setChildrenPosition(function (state) { return state.slice(0, -1); });
                                setNestedUpdateCount(nestedUpdateCount + 1);
                            }
                        }
                        if (!hasOverlaps &&
                            siblings.length === childrenPosition.length &&
                            childrenPosition.length == children.length) {
                            var t1 = performance.now();
                            console.log("FINISH", nestedUpdateCount);
                            console.log("Marquee took " + (t1 - t0) / nestedUpdateCount + " milliseconds per try.");
                            console.log("Marquee took " + (t1 - t0) + " milliseconds and " + nestedUpdateCount + " tries total.");
                            onFinish();
                        }
                    }
                }
                if (containerSize[0] > 0 &&
                    containerSize[1] > 0 &&
                    childrenPosition.length < children.length) {
                    var childPosCandidate_1 = {
                        x: util_1.randomIntFromInterval(0, containerSize[0]),
                        y: util_1.randomIntFromInterval(0, containerSize[1]),
                        scale: util_1.randomFloatFromInterval(minScale, maxScale),
                    };
                    setChildrenPosition(function (state) { return __spreadArrays(state, [childPosCandidate_1]); });
                    setNestedUpdateCount(nestedUpdateCount + 1);
                }
                // reset
                if (nestedUpdateCount > 0 && nestedUpdateCount % resetAfterTries === 0) {
                    setChildrenPosition([]);
                }
            }
        }
    }, [
        nestedUpdateCount,
        childrenPosition,
        childrenPosition.length,
        children.length,
        containerSize,
        scatterRandomly,
        retryAfterExceedingUpdateDepthTrigger,
    ]);
    react_1.useEffect(function () {
        if (nestedUpdateCount >= 50) {
            var resetRenderTimer_1 = setTimeout(function () {
                setNestedUpdateCount(0);
                setRetryAfterExceedingUpdateDepthTrigger(retryAfterExceedingUpdateDepthTrigger + 1);
            });
            return function () { return clearTimeout(resetRenderTimer_1); };
        }
    }, [nestedUpdateCount, retryAfterExceedingUpdateDepthTrigger]);
    return (react_1.default.createElement("div", { className: "container", ref: containerRef },
        react_1.default.createElement("div", { className: "marquee", ref: marqueeRef, style: { animationDuration: animationDuration + "s" } },
            scatterRandomly &&
                childrenPosition.map(function (pos, index) { return (react_1.default.createElement(Child_1.default, { left: pos.x, top: pos.y, scale: pos.scale, key: index, scatterRandomly: true }, children[index])); }),
            !scatterRandomly && children.map(function (child, index) { return react_1.default.createElement(Child_1.default, { key: index }, child); })),
        react_1.default.createElement("div", { className: "marquee repeater", style: { animationDuration: animationDuration + "s" } },
            scatterRandomly &&
                childrenPosition.map(function (pos, index) { return (react_1.default.createElement(Child_1.default, { left: pos.x, top: pos.y, scale: pos.scale, key: "repeater-child-" + index, scatterRandomly: true }, children[index])); }),
            !scatterRandomly && children.map(function (child, index) { return react_1.default.createElement(Child_1.default, { key: index }, child); }))));
};
Slider.defaultProps = {
    velocity: 30,
    minScale: 1,
    maxScale: 1,
    scatterRandomly: false,
    // the more elements, the higher you should put this.
    // change in hundred or thousand steps even
    resetAfterTries: 100,
    onFinish: function () { },
};
exports.default = Slider;
//# sourceMappingURL=SliderLayoutEffect.js.map